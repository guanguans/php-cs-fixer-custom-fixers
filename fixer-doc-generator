#!/usr/bin/env php
<?php

declare(strict_types=1);

/**
 * Copyright (c) 2025 guanguans<ityaozm@gmail.com>
 *
 * For the full copyright and license information, please view
 * the LICENSE file that was distributed with this source code.
 *
 * @see https://github.com/guanguans/php-cs-fixer-custom-fixers
 */

use Guanguans\PhpCsFixerCustomFixers\Fixer\AbstractFixer;
use Guanguans\PhpCsFixerCustomFixers\Fixer\CommandLineTool\XmlLintFixer;
use Guanguans\PhpCsFixerCustomFixers\Fixer\InlineHtml\DoctrineSqlFixer;
use Guanguans\PhpCsFixerCustomFixers\Fixer\InlineHtml\JsonFixer;
use Guanguans\PhpCsFixerCustomFixers\Fixer\InlineHtml\PhpMyAdminSqlFixer;
use Guanguans\PhpCsFixerCustomFixers\Fixers;
use PhpCsFixer\Fixer\ConfigurableFixerInterface;
use PhpCsFixer\Fixer\DeprecatedFixerInterface;
use PhpCsFixer\Fixer\FixerInterface;
use PhpCsFixer\Fixer\WhitespacesAwareFixerInterface;
use PhpCsFixer\FixerDefinition\CodeSampleInterface;
use PhpCsFixer\FixerFactory;
use PhpCsFixer\RuleSet\RuleSet;
use PhpCsFixer\Tokenizer\Tokens;
use PhpCsFixer\Utils;
use PhpCsFixer\WhitespacesFixerConfig;
use SebastianBergmann\Diff\Differ;
use SebastianBergmann\Diff\Output\StrictUnifiedDiffOutputBuilder;

require __DIR__.'/vendor/autoload.php';

exit((new DocGenerator)->generate());

/**
 * @see https://github.com/kubawerlos/php-cs-fixer-custom-fixers/blob/main/.dev-tools/src/Readme/ReadmeCommand.php
 *
 * @internal
 */
final class DocGenerator
{
    private const README_PLACEHOLDER_START = '<!-- fixerdoc-start -->';
    private const README_PLACEHOLDER_END = '<!-- fixerdoc-end -->';

    public function generate(): int
    {
        assert_options(\ASSERT_BAIL, 1);
        $_SERVER['argv'] ??= [];

        if (!\in_array('--dry-run', $_SERVER['argv'], true)) {
            $_SERVER['argv'][] = '--dry-run';
        }

        return $this->renderToReadme(str_replace('<pre>', htmlspecialchars('<pre>'), trim($this->fixers())));
    }

    private function renderToReadme(string $markdownFileContent): int
    {
        $path = getcwd().'/README.md';
        $originalContents = file_get_contents($path);

        $contents = preg_replace(
            '#'.preg_quote(self::README_PLACEHOLDER_START, '#').'(.*?)'.
            preg_quote(self::README_PLACEHOLDER_END, '#').'#s',
            self::README_PLACEHOLDER_START.\PHP_EOL.$markdownFileContent.\PHP_EOL.self::README_PLACEHOLDER_END,
            $originalContents
        );
        \assert(\is_string($contents));

        if (!\in_array('--dry-update', Guanguans\PhpCsFixerCustomFixers\Support\Utils::argv(), true)) {
            file_put_contents($path, $contents);
        }

        return $originalContents === $contents ? 0 : 1;
    }

    private function fixers(): string
    {
        $output = '';

        $fixers = iterator_to_array(new Fixers);
        usort($fixers, static fn (FixerInterface $a, FixerInterface $b): int => strcmp(\get_class($a), \get_class($b)));

        foreach ($fixers as $fixer) {
            if (
                !$fixer instanceof DoctrineSqlFixer
                && !$fixer instanceof PhpMyAdminSqlFixer
                && !$fixer instanceof JsonFixer
                && !$fixer instanceof XmlLintFixer
            ) {
                continue;
            }

            if ($fixer instanceof WhitespacesAwareFixerInterface) {
                $fixer->setWhitespacesConfig(new WhitespacesFixerConfig);
            }

            $reflectionClass = new ReflectionClass($fixer);

            $output .= \sprintf(
                "\n### %s\n\n> %s",
                $reflectionClass->getShortName(),
                $fixer->getDefinition()->getSummary(),
            );

            if ($fixer instanceof DeprecatedFixerInterface) {
                $fixers = (new FixerFactory)
                    ->registerBuiltInFixers()
                    ->registerCustomFixers(new Fixers)
                    ->useRuleSet(new RuleSet(array_combine($names = $fixer->getSuccessorsNames(), array_pad([], \count($names), true))))
                    ->getFixers();

                $successors = array_map(
                    static fn (FixerInterface $fixer): string => $fixer instanceof AbstractFixer
                        ? (new ReflectionObject($fixer))->getShortName()
                        : $fixer->getName(),
                    $fixers,
                );

                $output .= \sprintf("\n\nDEPRECATED: use `%s` instead.", implode('`, `', $successors));
            }

            if ($fixer->isRisky()) {
                $riskyDescription = $fixer->getDefinition()->getRiskyDescription();
                $starts = [
                    'Fixer could be risky if' => 'when',
                    'Risky when' => 'when',
                ];

                foreach ($starts as $from => $to) {
                    if (str_starts_with($riskyDescription, $from)) {
                        $riskyDescription = $to.substr($riskyDescription, \strlen($from));
                    }
                }

                $output .= \sprintf(
                    "\n\n*Risky: %s.*",
                    lcfirst(rtrim($riskyDescription, '.')),
                );
            }

            if ($fixer instanceof ConfigurableFixerInterface) {
                $output .= "\n\nConfiguration options:\n";

                foreach ($fixer->getConfigurationDefinition()->getOptions() as $option) {
                    if ($option->getAllowedValues() !== null) {
                        $allowed = array_map(
                            static fn (string $value): string => \sprintf("'%s'", $value),
                            $option->getAllowedValues()
                        );
                    } else {
                        /** @var list<string> $allowed */
                        $allowed = $option->getAllowedTypes();
                    }

                    $output .= \sprintf(
                        "\n- `%s` (`%s`): %s; defaults to `%s`",
                        $option->getName(),
                        implode('`, `', $allowed),
                        lcfirst(rtrim($option->getDescription(), '.')),
                        Utils::toString($option->getDefault()),
                    );
                }
            }

            $codeSample = $fixer->getDefinition()->getCodeSamples()[0];
            \assert($codeSample instanceof CodeSampleInterface);

            $originalCode = $codeSample->getCode();

            if ($fixer instanceof ConfigurableFixerInterface) {
                $fixer->configure($codeSample->getConfiguration() ?? []);
            }

            $tokens = Tokens::fromCode($originalCode);
            $fixer->fix($this->createSplFileInfoDouble($fixer), $tokens);
            $fixedCode = $tokens->generateCode();

            $output .= \sprintf(
                "\n\n```diff\n%s\n```\n",
                $this->diff($originalCode, $fixedCode),
            );
        }

        return $output;
    }

    private function diff(string $from, string $to): string
    {
        static $differ;

        if (null === $differ) {
            $differ = new Differ(new StrictUnifiedDiffOutputBuilder([
                'contextLines' => 1024,
                'fromFile' => '',
                'toFile' => '',
            ]));
        }

        $diff = $differ->diff($from, $to);

        if (!str_contains($diff, "\n")) {
            return $diff;
        }

        $start = strpos($diff, "\n", 10);
        \assert(\is_int($start));

        return (string) substr($diff, $start + 1, -1);
    }

    private function createSplFileInfoDouble(AbstractFixer $fixer): SplFileInfo
    {
        return new class(getcwd().\DIRECTORY_SEPARATOR.'file.'.(fn () => $this->defaultExtensions()[0])->call($fixer)) extends SplFileInfo {
            public function __construct(string $filename)
            {
                parent::__construct($filename);
            }

            public function getRealPath(): string
            {
                return $this->getPathname();
            }
        };
    }
}
